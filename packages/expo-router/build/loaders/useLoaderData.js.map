{"version":3,"file":"useLoaderData.js","sourceRoot":"","sources":["../../src/loaders/useLoaderData.ts"],"names":[],"mappings":"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","sourcesContent":["import { use } from 'react';\n\nimport { ServerDataLoaderContext } from './ServerDataLoaderContext';\nimport { useRouteNode } from '../Route';\nimport { useLocalSearchParams } from '../hooks';\nimport { resolveHref } from '../link/href';\nimport { LoaderFunction } from '../types';\n\nconst loaderDataCache = new Map<string, any>();\nconst loaderPromiseCache = new Map<string, Promise<any>>();\n\nexport function useLoaderData<T = any>(loader: LoaderFunction<T>): T {\n  const routeNode = useRouteNode();\n  const params = useLocalSearchParams();\n  const serverDataLoaderContext = use(ServerDataLoaderContext);\n\n  if (!routeNode) {\n    throw new Error('No route node found. This is likely a bug in expo-router.');\n  }\n\n  const resolvedPath = `/${resolveHref({ pathname: routeNode?.route, params })}`;\n\n  // First invocation of this hook will happen server-side, so we look up the loaded data from context\n  if (serverDataLoaderContext) {\n    return serverDataLoaderContext[resolvedPath];\n  }\n\n  // The second invocation happens after the client has hydrated on initial load, so we look up the data injected\n  // by `<PreloadedDataScript />` using `globalThis.__EXPO_ROUTER_LOADER_DATA__`\n  if (typeof window !== 'undefined' && globalThis.__EXPO_ROUTER_LOADER_DATA__) {\n    if (globalThis.__EXPO_ROUTER_LOADER_DATA__[resolvedPath]) {\n      return globalThis.__EXPO_ROUTER_LOADER_DATA__[resolvedPath];\n    }\n  }\n\n  // Check cache for route data\n  if (loaderDataCache.has(resolvedPath)) {\n    return loaderDataCache.get(resolvedPath);\n  }\n\n  // Fetch data if not cached\n  if (!loaderPromiseCache.has(resolvedPath)) {\n    const promise = fetchLoaderModule(resolvedPath)\n      .then((data) => {\n        loaderDataCache.set(resolvedPath, data);\n        return data;\n      })\n      .catch((error) => {\n        console.error(`Failed to load loader data for route: ${resolvedPath}:`, error);\n        throw new Error(`Failed to load loader data for route: ${resolvedPath}`, {\n          cause: error,\n        });\n      })\n      .finally(() => {\n        loaderPromiseCache.delete(resolvedPath);\n      });\n\n    loaderPromiseCache.set(resolvedPath, promise);\n  }\n\n  return use(loaderPromiseCache.get(resolvedPath)!);\n}\n\n/**\n * Fetches and parses a loader module from the given route path.\n * This works in all environments including:\n * 1. Development with Metro dev server (see `LoaderModuleMiddleware`)\n * 2. Production with static files (SSG)\n * 3. SSR environments\n */\nexport async function fetchLoaderModule(routePath: string): Promise<any> {\n  const loaderPath = `/_expo/loaders${routePath}.js`;\n\n  // NOTE(@hassankhan): Might be a good idea to convert `loaderPath` to an `URL` object\n  const response = await fetch(loaderPath);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch loader data: ${response.status}`);\n  }\n\n  const text = await response.text();\n  // Modules are generated as: export default {json}\n  const match = text.match(/export default (.+)$/m);\n  if (match) {\n    return JSON.parse(match[1]);\n  }\n\n  throw new Error('Invalid loader module format');\n}\n"]}